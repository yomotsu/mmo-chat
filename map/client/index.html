<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>=^.^=</title>
<style>
body{margin: 0;padding: 0; background: #000;}
canvas{display: block;}
</style>
</head>
<body>

<script src="js/lib/three.min.js"></script>
<script src="js/lib/meshwalk.min.js"></script>
<script src="js/lib/meshwalk.TPS.min.js"></script>
<script src="http://localhost:3004/socket.io/socket.io.js"></script>
<script>

var MOC = {};

MOC.PlayerCharacter3D = function ( params ) {

  this.id   = params.id; // socket.io 側で発行
  this.name = params.name;
  this.nameTexture = null;
  this.mesh = new THREE.Mesh(
    new THREE.SphereGeometry( MOC.PlayerCharacter3D.playerRadius, 16, 16 ),
    new THREE.MeshBasicMaterial( { color: 0xff0000,  wireframe: true} )
  );
  this.mesh.position.set( 0, 30, 0 );
  this.characterController = new MW.CharacterController( this.mesh, MOC.PlayerCharacter3D.playerRadius );
  // this.scene.add( playerObjectHolder );
  // this.world.add( this.playerController );

}
MOC.PlayerCharacter3D.prototype = {

  updatePosition: function () {
  // vent.addEventListener( 'beforerender', function () {

  //   animationController.mesh.position.set(
  //     playerController.center.x,
  //     playerController.center.y - playerController.radius,
  //     playerController.center.z
  //   );

  //   animationController.mesh.rotation.y = playerController.direction + Math.PI;

  // } );
  }
}

MOC.PlayerCharacter3D.playerRadius = 1;






MOC.view3d = {

  init: function () {
    
    this.width  = window.innerWidth,
    this.height = window.innerHeight,
    this.clock  = new THREE.Clock(),
    this.scene  = new THREE.Scene(),
    this.camera = new THREE.PerspectiveCamera( 40, this.width / this.height, 1, 1000 );
    this.camera.position.set( 0, 5, 30 );
    this.renderer = new THREE.WebGLRenderer();
    this.renderer.setSize( this.width, this.height );
    document.body.appendChild( this.renderer.domElement );

    // 30m * 3 world
    this.world = new MW.World();
    var min = new THREE.Vector3( -15, -15, -15 );
    var max = new THREE.Vector3(  15,  15,  15 );
    var partition = 5;
    this.octree = new MW.Octree( min, max, partition );
    this.world.add( this.octree );

    this.playerPool = [];

    this.addMe();
    this.loadLevel();

  },

  addMe: function () {

    var that = this;
    this.playerCharacter = new MOC.PlayerCharacter3D( {
      // id は、自キャラでは後でsocketでかえってきた情報を使う
      name: 'yomotsu',
      type: 1
    } );
    this.scene.add( this.playerCharacter.mesh );
    this.world.add( this.playerCharacter.characterController );

    this.keyInputControl  = new MW.KeyInputControl();
    this.tpsCameraControl = new MW.TPSCameraControl(
      this.camera, // three.js camera
      this.playerCharacter.mesh, // tracking object
      {
        el: this.renderer.domElement,
        offset: new THREE.Vector3( 0, 1.8, 0 ), // eye height
        // radius: 1, // default distance of the character to the camera
        // minRadius: 1,
        // maxRadius: 80,
        rigidObjects: []
      }
    );

    // bind events
    this.playerCharacter.characterController.inputTimeout = null;
    this.keyInputControl.addEventListener( 'movekeyhold',    function () {

      that.playerCharacter.characterController.inputTimeout = null;
      that.playerCharacter.characterController.isRunning = true;

    } );

    this.keyInputControl.addEventListener( 'movekeyrelease', function () {

      that.playerCharacter.characterController.inputTimeout = Date.now() + 500;

      setTimeout( function () {

        if ( that.keyInputControl.isMoveKeyHolded ) { return; }
        that.playerCharacter.characterController.isRunning = false;

      }, 500 );

    } );

    this.keyInputControl.addEventListener( 'jumpkeypress', function () {

      that.playerCharacter.characterController.jump();

    } );

    // synk with keybord input and camera control input
    this.keyInputControl.addEventListener( 'movekeychange', syncRotation );
    // the 'updated' event is fired by `tpsCameraControl.update()`
    this.tpsCameraControl.addEventListener( 'updated', syncRotation );

    function syncRotation () {

      if ( that.playerCharacter.characterController.isIdling ) { return; }
      var cameraFrontAngle = that.tpsCameraControl.getFrontAngle();
      var characterFrontAngle = that.keyInputControl.getFrontAngle();
      that.playerCharacter.characterController.direction = THREE.Math.degToRad( 360 ) - cameraFrontAngle + characterFrontAngle;

    }

  },

  addOtherPlayer: function ( data ) {

    var otherPlayerCharacter = new MOC.PlayerCharacter3D( {
      id:   data.id,
      name: data.name,
      type: data.type
    } );
    this.scene.add( otherPlayerCharacter.mesh );
    this.world.add( otherPlayerCharacter.characterController );
    this.playerPool.push( otherPlayerCharacter );

  },

  loadLevel: function () {

    var that   = this;
    var loader = new THREE.JSONLoader();
    var box, terrain;

    loader.load( 'terrain.json', function( geo, mat ) {

      box = new THREE.Mesh(
        new THREE.BoxGeometry( 14, 1, 5 ),
        new THREE.MeshNormalMaterial()
      );
      box.position.set( -3, 7.5, -13 );
      that.scene.add( box );
      that.scene.add( new THREE.WireframeHelper( box ) );
      that.octree.importThreeMesh( box );


      terrain = new THREE.Mesh(
        geo,
        new THREE.MeshNormalMaterial()
        // new THREE.MeshFaceMaterial( mat )
      );
      terrain.scale.set( 2, 2, 2 );
      that.scene.add( terrain );
      that.scene.add( new THREE.WireframeHelper( terrain ) );
      that.octree.importThreeMesh( terrain );
      that.tpsCameraControl.rigidObjects.push( terrain );

    } );

  },

  allOtherPlayersControler: function () {

    this.playerPool.forEach( function ( pc ) {


      // pc.characterController.isRunning = true;

    } );

  },

  update: function () {

    this.allOtherPlayersControler();

  },

  render: function ( delta ) {

    this.world.step( delta );
    this.tpsCameraControl.update();
    this.renderer.render( this.scene, this.camera );

  },

  connect: function () {

    var that = this;
    var socket = io( 'http://localhost:3004', { transports: [ 'websocket' ] } );

    // 接続完了時
    socket.on('connect', function() {

      //自分の状態をサーバに送る
      socket.emit( 'addnewplayer', {
        name     : that.playerCharacter.name,
        type     : that.playerCharacter.type,
        position : [
          that.playerCharacter.characterController.center.x,
          that.playerCharacter.characterController.center.y,
          that.playerCharacter.characterController.center.z
        ],
        velocity : [
          that.playerCharacter.characterController.velocity.x,
          that.playerCharacter.characterController.velocity.y,
          that.playerCharacter.characterController.velocity.z
        ],
        direction    : that.playerCharacter.characterController.direction,
        isGrounded   : that.playerCharacter.characterController.isGrounded,
        isIdling     : that.playerCharacter.characterController.isIdling,
        isJumping    : that.playerCharacter.characterController.isJumping,
        isOnSlope    : that.playerCharacter.characterController.isOnSlope,
        isRunning    : that.playerCharacter.characterController.isRunning,
        jumpStartTime: that.playerCharacter.characterController.jumpStartTime,
        inputTimeout : that.playerCharacter.characterController.inputTimeout
      } );

    } );

    // 接続成功時、[myid] と [接続済みの他のプレイヤー情報] が返ってくる
    socket.on( 'myid', function ( data ) {

      that.playerCharacter.id = data.myID;

      // 接続済みの他プレイヤーをクライアント側でも反映
      for ( var i in data.players ) {

        that.addOtherPlayer( data.players[ i ] );

      }

    } );

    // 途中で新たにプレイヤーが追加で接続した場合
    socket.on( 'addnewplayer', function ( data ) {

      that.addOtherPlayer( data );

    } );

    socket.on( 'sync', function ( allPlayersData ) {

      that.playerPool.forEach( function ( item ) {

        var playerData = allPlayersData[ item.id ];

        item.characterController.center.set(
          playerData.position[ 0 ],
          playerData.position[ 1 ],
          playerData.position[ 2 ]
        );
        item.characterController.velocity.set(
          playerData.velocity[ 0 ],
          playerData.velocity[ 1 ],
          playerData.velocity[ 2 ]
        );
        item.characterController.direction     = playerData.direction;
        item.characterController.isGrounded    = playerData.isGrounded;
        item.characterController.isIdling      = playerData.isIdling;
        item.characterController.isJumping     = playerData.isJumping;
        item.characterController.isOnSlope     = playerData.isOnSlope;
        item.characterController.isRunning     = playerData.isRunning;
        item.characterController.jumpStartTime = playerData.jumpStartTime;
        item.characterController.inputTimeout  = playerData.inputTimeout;

      } );
      // app.playersData.watchAndSync();

      var myData = {
        position : [
          that.playerCharacter.characterController.center.x,
          that.playerCharacter.characterController.center.y,
          that.playerCharacter.characterController.center.z
        ],
        velocity : [
          that.playerCharacter.characterController.velocity.x,
          that.playerCharacter.characterController.velocity.y,
          that.playerCharacter.characterController.velocity.z
        ],
        direction    : that.playerCharacter.characterController.direction,
        isGrounded   : that.playerCharacter.characterController.isGrounded,
        isIdling     : that.playerCharacter.characterController.isIdling,
        isJumping    : that.playerCharacter.characterController.isJumping,
        isOnSlope    : that.playerCharacter.characterController.isOnSlope,
        isRunning    : that.playerCharacter.characterController.isRunning,
        jumpStartTime: that.playerCharacter.characterController.jumpStartTime,
        inputTimeout : that.playerCharacter.characterController.inputTimeout
      };

      socket.emit( 'upload', myData );

    } );

    socket.on( 'playerleft', function ( id ) {

      // TODO idから要素を取り除く仕組みを作る
      console.log( id );
      // app.playersData.remove( id );

    } );

  },

  dispose: function ( player ) {

    var pool = this.world.characterPool;
    pool.splice( pool.indexOf( player.controller ), 1 );
    this.scene.remove( player.object ); // cloneされたメッシュ

  }

}

MOC.view3d.init();
MOC.view3d.connect();

var count = 0;
;( function update () {

  count++;
  if(count===900){return;}

  requestAnimationFrame( update );
  var delta = MOC.view3d.clock.getDelta();
  MOC.view3d.update.bind( MOC.view3d )();
  MOC.view3d.render( delta );

} )();
</script>

</body>
</html>
